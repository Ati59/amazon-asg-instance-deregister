# Amazon ASG Instance Deregister

(This is a fork of the aws example [amazon-k8s-node-drainer](https://github.com/aws-samples/amazon-k8s-node-drainer))

This project provides a means to gracefully deregister instances from all the targets group it is associated with. It uses the ASG lifecycle hook feature.

The main goal of this deregistration is to launch the ELB draining session before a node is killed by the ELB procedure, specially on a k8s cluster.

Below is a brief explanation of the folder structure of the project:

```bash
.
├── README.md                   <-- This instructions file
├── build_and_deploy.sh         <-- Deployment script
├── drainer                     <-- Source code for the lambda function
│   ├── __init__.py
│   ├── handler.py              <-- Lambda function code
│   ├── aws_utils.py            <-- AWS ELB/ tools
└── template.yaml               <-- SAM Template
```

## Requirements

* [SAM CLI](https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html)
* AWS CLI already configured with Administrator permission
* [Python 3](https://www.python.org/downloads/)
* [Docker](https://www.docker.com/community-edition)

## Setup process

### Local development

## Packaging and deployment

AWS Lambda Python runtime requires a flat folder with all dependencies including the application. SAM will use `CodeUri` property to know where to look up for both application and dependencies:

```yaml
...
    DrainerFunction:
        Type: AWS::Serverless::Function
        Properties:
            CodeUri: drainer/
            ...
```

Firstly, we need a `S3 bucket` where we can upload our Lambda functions packaged as ZIP before we deploy anything - If 
you don't have a S3 bucket to store code artifacts then this is a good time to create one:

*Note: The S3 bucket needs to be in the AWS region used to deploy the Lambda.*

```bash
aws s3 mb s3://${BUCKET_NAME}
```

There is a convenience script in the root directory called `build_and_deploy.sh` that
wraps these three commands and takes your AWS profile as an argument (it will use the default profile
if a profile is not provided) and the S3 bucket created above.
```bash
./build_and_deploy.sh 
    ${BUCKET_NAME} \
    ${YOUR_AUTOSCALING_GROUP_NAME} \
    ${NAME} \
    ${YOUR_AWS_PROFILE}
```

> The `NAME` value is just used to name the CloudFormation stack to `asg-deregister-${NAME}`.

After deployment is complete you can run the following command to retrieve the API Gateway Endpoint URL:

```bash
aws cloudformation describe-stacks \
    --stack-name asg-deregister-${NAME} \
    --output table
``` 

## Testing the Drainer function

Run the following command to simulate an EC2 instance being terminated as part of a scale-in event:

```bash
aws autoscaling terminate-instance-in-auto-scaling-group --no-should-decrement-desired-capacity --instance-id <instance-id>
```

You must use this command for Auto Scaling Lifecycle hooks to be used. Terminating the instance via the EC2 Console or APIs will immediately terminate the instance, bypassing the lifecycle hooks.

## Fetch, tail, and filter Lambda function logs

To simplify troubleshooting, SAM CLI provides a command called `sam logs`. `sam logs` lets you fetch logs generated by your Lambda function from the command line. In addition to printing the logs on the terminal, this command has several  features to help you quickly find the bug.

`NOTE`: This command works for all AWS Lambda functions; not just the ones you deploy using SAM.

```bash
sam logs -n DrainerFunction --stack-name asg-deregister-${NAME} --tail
```

You can find more information and examples about filtering Lambda function logs in the [SAM CLI Documentation](https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-logging.html).

## Cleanup

In order to remove the Lambda function and Lifecycle Hook you can use the following sam CLI Command:

```bash
sam delete --stack-name asg-deregister-${NAME}
```
